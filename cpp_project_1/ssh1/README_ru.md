# SOCKS5 Proxy через SSH на C++

## Введение

Данный проект реализует SOCKS5 прокси-сервер на языке C++, который перенаправляет клиентские подключения через SSH-туннель к целевым серверам. Это позволяет клиентам подключаться к любым серверам по протоколу SOCKS5, при этом прокси безопасно пересылает трафик через SSH-соединение.

Реализация использует `Boost.Asio` для асинхронных сетевых операций и `libssh` для SSH-подключений. Прокси поддерживает одновременную работу с несколькими клиентами, обрабатывает протокол SOCKS5 и эффективно управляет SSH-сессиями и каналами.

## Особенности

- **SOCKS5 Прокси-сервер**: Реализует протокол SOCKS5 с поддержкой команды `CONNECT`.
- **SSH Туннелирование**: Безопасно перенаправляет клиентские подключения через SSH к целевым серверам.
- **Асинхронный ввод/вывод**: Использует `Boost.Asio` для неблокирующих сетевых операций.
- **Потокобезопасное логирование**: Обеспечивает синхронизированное логирование в многопоточной среде.
- **Управление SSH-сессиями**: Обрабатывает SSH-подключения, включая логику переподключения.
- **Поддержка IPv4 и доменных имен**: Обрабатывает как IPv4 адреса, так и доменные имена в запросах SOCKS5.
- **Настраиваемые SSH Опции**: Позволяет конфигурировать параметры SSH, такие как шифры, методы обмена ключами и другие.
- **Конфигурируемый пул потоков**: Позволяет регулировать количество потоков для обработки клиентских подключений.

## Зависимости

- **Boost C++ Libraries** (особенно Boost.Asio)
  - Сайт: [https://www.boost.org/](https://www.boost.org/)
- **libssh**
  - Сайт: [https://www.libssh.org/](https://www.libssh.org/)
- **C++11 или новее**: Требуется современный компилятор C++ с поддержкой стандарта C++11 или выше.

## Компиляция

Для компиляции кода убедитесь, что как Boost, так и libssh установлены на вашей системе. Вы можете использовать `g++` или `clang++` для компиляции кода.

### Команда компиляции

```bash
g++ -std=c++11 -o socks5_proxy ss.cpp -lboost_system -lboost_thread -lpthread -lssh
```

**Пояснение:**

- `-std=c++11`: Использование стандарта C++11.
- `-o socks5_proxy`: Имя выходного исполняемого файла.
- `ss.cpp`: Файл исходного кода.
- `-lboost_system -lboost_thread`: Подключение библиотек Boost.System и Boost.Thread.
- `-lpthread`: Подключение POSIX библиотеки потоков.
- `-lssh`: Подключение библиотеки libssh.

**Примечание:** Возможно, вам потребуется указать пути к заголовочным файлам и библиотекам, если они находятся в нестандартных директориях:

```bash
g++ -std=c++11 -I/путь/к/boost/include -I/путь/к/libssh/include \
    -L/путь/к/boost/lib -L/путь/к/libssh/lib \
    -o socks5_proxy ss.cpp -lboost_system -lboost_thread -lpthread -lssh
```

Замените `/путь/к/boost` и `/путь/к/libssh` на актуальные пути на вашей системе.

## Использование

После компиляции запустите прокси-сервер:

```bash
./socks5_proxy
```

По умолчанию сервер слушает на порту `1080` входящие подключения по протоколу SOCKS5 и подключается к SSH-серверу, указанному в коде.

## Конфигурация

Отредактируйте функцию `main` в файле `ss.cpp` для настройки параметров прокси и SSH:

```cpp
// Конфигурация SOCKS5 прокси-сервера
unsigned short port = 1080;           // Порт для прослушивания SOCKS5 прокси
std::size_t thread_pool_size = 1;     // Количество потоков для обработки подключений

// Детали подключения SSH
std::string ssh_host = "your_ssh_server_ip";
int ssh_port = 22; // Обычный SSH порт
std::string ssh_user = "your_username";
std::string ssh_password = "your_password";

// Опции SSH
int verbosity = SSH_LOG_PROTOCOL;     // Уровень логирования
long timeout = 5;                     // Таймаут подключения в секундах
std::string ciphers_c_s = "chacha20-poly1305,aes256-gcm@openssh.com,..."; // Шифры
std::string key_exchange = "curve25519-sha256,...";                      // Методы обмена ключами
std::string hmac_c_s = "hmac-sha2-256-etm@openssh.com,...";              // Алгоритмы HMAC
std::string hostkeys = "ssh-rsa,ssh-dss,ecdh-sha2-nistp256";             // Типы ключей хоста
std::string compression = "none";                                        // Настройка сжатия
```

**Важно:** Замените значения параметров на соответствующие вашей среде. Не используйте реальные пароли и конфиденциальную информацию в исходном коде.

## Подробное описание кода

Код состоит из нескольких классов и функций, которые совместно реализуют SOCKS5 прокси через SSH. Ниже представлено подробное описание каждого компонента.

### 1. Класс Logger

Класс `Logger` представляет собой потокобезопасный инструмент для логирования, обеспечивающий синхронизированный вывод сообщений из разных потоков.

**Заголовок:**

```cpp
class Logger {
public:
    template<typename... Args>
    static void log(Args... args);

    template<typename... Args>
    static void error(Args... args);

private:
    static std::mutex mutex_;
};
```

**Методы:**

- `log(Args... args)`: Выводит сообщения в `std::cout`.
- `error(Args... args)`: Выводит сообщения об ошибках в `std::cerr`.

**Реализация:**

Используется шаблонный метод с параметрами переменной длины для удобства вывода различных типов данных. Мьютекс `mutex_` обеспечивает синхронизацию доступа к стандартным потокам вывода.

**Пример использования:**

```cpp
Logger::log("Это сообщение лога.");
Logger::error("Это сообщение об ошибке.");
```

### 2. Класс SSHManager

Класс `SSHManager` управляет SSH-сессиями, включая установление соединения, аутентификацию, создание каналов и логику переподключения.

**Заголовок:**

```cpp
class SSHManager {
public:
    SSHManager(const std::string& host, int port, const std::string& user, const std::string& password,
               int verbosity, long timeout,
               const std::string& ciphers_c_s,
               const std::string& key_exchange,
               const std::string& hmac_c_s,
               const std::string& hostkeys,
               const std::string& compression);
    ~SSHManager();

    bool initialize();
    ssh_channel get_channel(const std::string& target_address, int target_port);
    bool is_connected();
    bool reconnect();
    std::string get_error_message();
    void decrement_channel_count();

private:
    // Детали SSH-сессии
    ssh_session ssh_session_;
    std::mutex mutex_;
    size_t active_channels_;
    bool reconnecting_;
    // Параметры конфигурации (host, port, user, и т.д.)
};
```

**Основные функции:**

- `initialize()`: Устанавливает SSH-сессию и выполняет аутентификацию.
- `get_channel(target_address, target_port)`: Открывает SSH-канал для перенаправления на целевой адрес и порт.
- `is_connected()`: Проверяет, установлено ли SSH-соединение.
- `reconnect()`: Пытается переподключить SSH-сессию в случае разрыва.
- `get_error_message()`: Возвращает сообщение об ошибке SSH-сессии.
- `decrement_channel_count()`: Уменьшает счетчик активных каналов при закрытии канала.

**Логика переподключения:**

Если SSH-сессия разорвана, `SSHManager` пытается переподключиться, прежде чем создавать новые каналы. Переподключение происходит только в том случае, если нет активных каналов, чтобы избежать разрыва текущих соединений.

**Пример использования в коде:**

Класс `SSHManager` используется объектами `Session` для управления SSH-каналами при перенаправлении подключений.

### 3. Класс Session

Класс `Session` обрабатывает одно клиентское подключение, осуществляет обработку протокола SOCKS5 и перенаправляет данные между клиентом и SSH-каналом.

**Заголовок:**

```cpp
class Session : public std::enable_shared_from_this<Session> {
public:
    Session(tcp::socket client_socket, boost::asio::io_context& io_context,
            std::shared_ptr<SSHManager> ssh_manager);
    void start();

private:
    void handle_handshake();
    void handle_request();
    void send_reply(unsigned char reply_code);
    void connect_to_target_via_ssh();
    void start_relay();
    void relay_client_to_ssh();
    void relay_ssh_to_client();
    void do_close();

    // Членские переменные (сокеты, буферы, целевой адрес и т.д.)
};
```

**Основные функции:**

- `start()`: Инициализирует сессию, начиная обработку рукопожатия SOCKS5.
- `handle_handshake()`: Обрабатывает начальное рукопожатие протокола SOCKS5 с клиентом.
- `handle_request()`: Парсит запрос клиента и извлекает целевой адрес и порт.
- `connect_to_target_via_ssh()`: Получает SSH-канал к целевому серверу.
- `start_relay()`: Начинает перенаправление данных между клиентом и SSH-каналом.
- `do_close()`: Закрывает сокеты и SSH-каналы, освобождая ресурсы.

**Обработка протокола SOCKS5:**

- **Фаза рукопожатия:**
  - Читает версию и методы аутентификации от клиента.
  - Отвечает выбранным методом (в данном случае без аутентификации).
- **Фаза запроса:**
  - Читает запрос клиента для подключения к целевому серверу.
  - Поддерживает как IPv4 адреса, так и доменные имена.
- **Фаза ответа:**
  - Отправляет ответ клиенту, указывая на успех или неудачу подключения.

**Перенаправление данных:**

- **От клиента к SSH-каналу:**
  - Асинхронно читает данные от клиента и записывает их в SSH-канал.
- **От SSH-канала к клиенту:**
  - Читает данные из SSH-канала и отправляет их клиенту.
- Используются асинхронные операции чтения и записи для эффективного перенаправления данных.

### 4. Класс Socks5Proxy

Класс `Socks5Proxy` слушает входящие клиентские подключения и создает объекты `Session` для их обработки.

**Заголовок:**

```cpp
class Socks5Proxy {
public:
    Socks5Proxy(boost::asio::io_context& io_context, unsigned short port, std::size_t thread_pool_size,
               const std::string& ssh_host, int ssh_port,
               const std::string& ssh_user, const std::string& ssh_password,
               int verbosity, long timeout,
               const std::string& ciphers_c_s,
               const std::string& key_exchange,
               const std::string& hmac_c_s,
               const std::string& hostkeys,
               const std::string& compression);
    void start();
    void run();

private:
    void do_accept();

    // Членские переменные (io_context, acceptor, SSHManager и т.д.)
};
```

**Основные функции:**

- `start()`: Начинает прием клиентских подключений.
- `run()`: Запускает `io_context` и пул потоков.
- `do_accept()`: Асинхронно принимает новые клиентские подключения.

**Логика работы:**

- Принимает новое подключение.
- Создает новый объект `Session` для обработки этого подключения.
- Запускает сессию, вызывая `start()`.

### 5. Функция main

Функция `main` настраивает параметры прокси-сервера и запускает его.

**Основные шаги:**

- Определяет параметры конфигурации (порт прокси, детали SSH, опции SSH).
- Инициализирует `boost::asio::io_context` и `Socks5Proxy`.
- Запускает прокси и `io_context`.

**Пример кода:**

```cpp
int main() {
    try {
        // Параметры конфигурации
        unsigned short port = 1080;
        std::size_t thread_pool_size = 1;
        // Детали подключения SSH и опции
        // ...

        boost::asio::io_context io_context;
        Socks5Proxy proxy(io_context, port, thread_pool_size, /* Параметры SSH */);
        proxy.start();

        Logger::log("Socks5Proxy: Запущен на порту ", port, " с пулом потоков размером ", thread_pool_size, ".");
        proxy.run();
    }
    catch (std::exception& e) {
        Logger::error("Main: Исключение: ", e.what());
    }
    return 0;
}
```

## Как это работает

1. **Подключение клиента:**
   - Клиент подключается к прокси на указанном порту.
   - `Socks5Proxy` принимает подключение и создает новый объект `Session`.

2. **Рукопожатие SOCKS5:**
   - `Session` обрабатывает рукопожатие по протоколу SOCKS5, согласовывая использование метода без аутентификации.

3. **Обработка запроса SOCKS5:**
   - `Session` читает запрос клиента для подключения к целевому серверу.
   - Поддерживаются как IPv4 адреса, так и доменные имена.

4. **Установление SSH-канала:**
   - `Session` запрашивает у `SSHManager` SSH-канал к целевому серверу.
   - Если SSH-сессия разорвана, `SSHManager` пытается переподключиться.

5. **Перенаправление данных:**
   - `Session` начинает перенаправлять данные между клиентом и целевым сервером через SSH-канал.
   - Используются асинхронные операции чтения и записи для эффективной передачи данных.

6. **Завершение сессии:**
   - Когда сессия завершается (например, клиент разрывает соединение), `Session` закрывает сокеты и SSH-канал.
   - `SSHManager` обновляет счетчик активных каналов.

## Используемые библиотеки и стандарты

- **Boost.Asio**: Обеспечивает асинхронную сетевую функциональность.
  - Документация: [Boost.Asio Documentation](https://www.boost.org/doc/libs/release/doc/html/boost_asio.html)
- **libssh**: Используется для SSH-подключений и управления каналами.
  - Документация: [libssh Documentation](https://www.libssh.org/documentation/)
- **Стандарт C++11**: Используются современные возможности C++, такие как умные указатели, лямбда-выражения и многопоточность.

## Обработка ошибок и логика переподключения

- **Управление SSH-сессией:**
  - `SSHManager` проверяет, установлено ли SSH-соединение.
  - Если соединение разорвано, пытается переподключиться перед установлением новых каналов.
- **Отслеживание активных каналов:**
  - Поддерживается счетчик активных SSH-каналов, чтобы предотвратить переподключение при наличии активных каналов.
- **Обработка ошибок в сессии:**
  - `Session` отправляет соответствующие коды ошибок SOCKS5 клиенту в случае возникновения ошибки.
  - Гарантирует корректное освобождение ресурсов при возникновении ошибок.

## Ограничения и возможные улучшения

- **Отсутствие аутентификации для клиентов SOCKS5:**
  - В текущей реализации прокси не требует аутентификации от клиентов.
  - В будущем можно реализовать методы аутентификации SOCKS5.
- **Поддержка IPv6:**
  - Код содержит задел для поддержки IPv6, но в основном обрабатывает IPv4 адреса и доменные имена.
- **Гибкость конфигурации:**
  - Конфигурация жестко задана в функции `main`.
  - Можно расширить функциональность, добавив чтение настроек из конфигурационного файла или параметров командной строки.
- **Дополнительные команды SOCKS5:**
  - Поддерживается только команда `CONNECT`.
  - Можно расширить поддержку, добавив команды `BIND` и `UDP ASSOCIATE`.
- **Управление ресурсами:**
  - В текущей реализации возможны утечки ресурсов при определенных условиях.
  - Рекомендуется использовать умные указатели и более строгую обработку исключений для управления ресурсами.

## Заключение

Этот проект предоставляет надежную реализацию SOCKS5 прокси-сервера на C++, который перенаправляет подключения через SSH. Используя `Boost.Asio` для сетевых операций и `libssh` для управления SSH-сессиями, он обеспечивает безопасную и эффективную обработку клиентских подключений. Код демонстрирует эффективное использование современных возможностей C++, асинхронного программирования и обеспечения потокобезопасности.

## Контакты

Для вопросов или предложений по улучшению проекта, пожалуйста, свяжитесь с автором или отправьте запрос на внесение изменений (pull request) на GitHub.

## Дополнительная информация о проекте

### Расширенные возможности

- **Поддержка нескольких клиентов:**
  - Проект разработан с учетом возможности одновременной обработки нескольких клиентских подключений.
  - Использование пула потоков и асинхронных операций позволяет эффективно масштабировать сервер.

- **Безопасность:**
  - Использование SSH для туннелирования обеспечивает шифрование данных между прокси и целевым сервером.
  - Настраиваемые параметры SSH позволяют использовать современные и безопасные алгоритмы шифрования и хеширования.

- **Логирование:**
  - Подробное логирование помогает в диагностике и мониторинге работы сервера.
  - Уровень детализации логов можно настраивать через параметры SSH.

### Потенциальные области применения

- **Обход ограничений сети:**
  - Прокси можно использовать для обхода брандмауэров и других сетевых ограничений, перенаправляя трафик через SSH-туннель.
  
- **Анонимизация:**
  - Позволяет скрыть реальный IP-адрес клиента, перенаправляя трафик через удаленный сервер.
  
- **Безопасный доступ к внутренним ресурсам:**
  - Может использоваться для безопасного доступа к ресурсам, находящимся во внутренней сети, через SSH-туннель.

### Рекомендации по улучшению

- **Улучшение управления ресурсами:**
  - Внедрение умных указателей (`std::shared_ptr`, `std::unique_ptr`) для автоматического управления временем жизни объектов.
  - Обработка исключений во всех асинхронных операциях для предотвращения аварийного завершения работы сервера.

- **Расширение функциональности:**
  - Добавление поддержки аутентификации SOCKS5 клиентов (например, по имени пользователя и паролю).
  - Реализация поддержки IPv6 адресов полностью.

- **Улучшение безопасности:**
  - Хранение конфиденциальных данных (например, паролей) в защищенном виде.
  - Добавление механизма обновления SSH-ключей и сертификатов.

### Тестирование и отладка

- **Юнит-тесты:**
  - Разработка набора юнит-тестов для проверки корректности отдельных компонентов системы.
  
- **Интеграционное тестирование:**
  - Тестирование взаимодействия между различными компонентами, включая внешние SSH-серверы и клиенты SOCKS5.

- **Нагрузочное тестирование:**
  - Оценка производительности сервера под высокой нагрузкой и оптимизация узких мест.

### Документация и поддержка

- **Автодокументация:**
  - Использование инструментов для автоматической генерации документации из кода (например, Doxygen).
  
- **Примеры использования:**
  - Предоставление примеров конфигурации и сценариев использования для различных случаев.

- **Сообщество:**
  - Создание сообщества пользователей и разработчиков для обмена опытом и совместного развития проекта.

### Лицензирование

- **Выбор лицензии:**
  - Определение лицензии для распространения проекта (например, MIT, GPL).
  
- **Авторские права:**
  - Указание информации об авторских правах и условиях использования.

---

**Примечание:** При разработке подобных проектов важно соблюдать законодательство и этические нормы, особенно в отношении безопасности и конфиденциальности данных. Необходимо убедиться, что использование прокси-сервера соответствует политике организации и не нарушает права третьих лиц.
